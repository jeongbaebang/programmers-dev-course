### generator
코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수.

#### 제너레이터 함수 특징
1. 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도(yield)할 수 있다.
2. 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다. (양방향)
3. 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.
4. 일반 함수처럼 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다.

#### yield*의 동작 방식
1.	다른 제너레이터와 연결:
yield*를 사용하면 현재 제너레이터의 흐름을 중단하고, 다른 제너레이터의 실행을 시작하거나 재개할 수 있습니다. 이 과정에서 외부 호출자는 두 제너레이터의 경계를 인식하지 못하고, 하나의 연속적인 제너레이터처럼 사용할 수 있습니다.
2.	반복 가능한 객체와 함께 사용:
yield*는 단순히 제너레이터 함수뿐만 아니라 배열, 문자열, Map, Set 등과 같은 모든 반복 가능한 객체와 함께 사용할 수 있습니다. 이를 통해 이터레이터를 반환하는 객체에서 값을 순차적으로 얻어올 수 있습니다.


### 제너레이터가 여전히 유용하게 사용될 수 있는 경우
#### 1. 데이터 스트리밍 처리
제너레이터는 데이터를 한 번에 하나씩 생성할 수 있으므로, 메모리 효율적인 데이터 스트리밍 처리에 유용합니다. 예를 들어, 대용량 파일을 한꺼번에 메모리에 로드하지 않고, 청크 단위로 처리할 수 있습니다.

```js
function* readLines(file) {
  const fileStream = fs.createReadStream(file, { encoding: 'utf8' });
  let buffer = '';
  
  for await (const chunk of fileStream) {
    buffer += chunk;
    let lines = buffer.split('\n');
    
    buffer = lines.pop();
    
    for (const line of lines) {
      yield line;
    }
  }
  
  if (buffer) {
    yield buffer;
  }
}
```
#### 2. 데이터 시퀀싱 및 동작 순서 제어
제너레이터는 내부 상태를 유지할 수 있어, 데이터를 순차적으로 생성하거나 특정 동작 순서를 제어하는 데 유용합니다. 예를 들어, 재귀적인 데이터 구조를 탐색하거나, 무한 시퀀스를 생성하는 경우에 사용할 수 있습니다.
```js
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
```
---
### 기술면접
#### 제너레이터(Generators)가 무엇인지 설명해주세요.
답변: 제너레이터는 function* 키워드로 정의되며, yield 키워드를 사용하여 여러 번의 호출에 걸쳐 값을 생성하고 반환할 수 있는 함수입니다. 제너레이터 함수는 호출될 때 제너레이터 객체를 반환하며, 이 객체는 next() 메서드를 사용하여 제너레이터 함수의 실행을 제어할 수 있습니다. 제너레이터는 상태를 유지하면서 여러 번 중단되고 다시 시작될 수 있어, 순차적인 데이터 생성, 무한한 데이터 스트림 생성 등에서 유용하게 사용됩니다.
#### 제너레이터와 일반 함수의 차이점을 설명해주세요.
답변: 제너레이터 함수와 일반 함수의 주요 차이점은 실행 제어와 상태 유지입니다. 일반 함수는 호출되면 전체 코드가 한 번에 실행되고 종료됩니다. 반면, 제너레이터 함수는 호출 시 즉시 실행되지 않고, 제너레이터 객체를 반환합니다. 이 객체의 next() 메서드를 호출할 때마다 함수가 중단된 지점에서부터 다시 실행됩니다. 또한, 제너레이터는 yield 키워드를 사용하여 값을 반환하고 실행을 일시 중단할 수 있으며, 제너레이터 객체를 통해 외부에서 값을 주입할 수도 있습니다.
#### 제너레이터 함수에서 yield 키워드는 어떤 역할을 하나요?
답변: yield 키워드는 제너레이터 함수의 실행을 일시 중단하고, 호출자에게 값을 반환하는 역할을 합니다. 제너레이터의 next() 메서드가 호출되면, yield 다음 표현식의 결과를 반환하며, 다시 호출되기 전까지 함수의 실행이 중단됩니다. 다음 next() 호출 시에는 마지막에 중단된 지점부터 함수가 재개됩니다. yield는 단순한 값뿐만 아니라 복잡한 표현식의 결과를 반환할 수도 있습니다.
#### 제너레이터에서 return과 yield의 차이는 무엇인가요?
답변: yield는 제너레이터의 실행을 중단하고 값을 반환하며, 이후 next() 호출 시 다시 실행을 재개할 수 있도록 합니다. 반면, return은 제너레이터의 실행을 완전히 종료하고, done: true와 함께 반환 값을 설정합니다. 즉, return을 만나면 더 이상 next()를 통해 제너레이터를 진행할 수 없으며, 제너레이터는 끝납니다.
#### 제너레이터는 어떤 상황에서 유용하게 사용되나요?
제너레이터는 다음과 같은 상황에서 유용하게 사용됩니다:

	1.	데이터 스트리밍: 대용량 데이터를 한 번에 메모리에 로드하지 않고, 필요할 때마다 데이터를 생성할 수 있습니다.
	2.	비동기 흐름 제어: 복잡한 비동기 작업을 순차적으로 처리하거나, 상태를 유지하면서 비동기 작업을 관리할 수 있습니다.
	3.	이터러블 구현: 커스텀 이터러블 객체를 쉽게 구현할 수 있어, for...of 루프나 전개 연산자 등에서 사용할 수 있습니다.
	4.	재귀 데이터 구조 탐색: 트리나 그래프와 같은 복잡한 데이터 구조를 효율적으로 탐색할 수 있습니다.
#### 제너레이터와 async/await의 차이점을 설명해주세요.
답변: 제너레이터와 async/await는 비동기 작업을 처리하는 데 사용할 수 있지만, 본질적으로 다른 개념입니다. 제너레이터는 상태를 유지하고 실행을 중단/재개할 수 있는 함수로, yield 키워드를 사용합니다. 반면, async/await는 비동기 작업을 동기식 코드처럼 작성할 수 있게 해주는 문법입니다. await는 Promise를 반환하는 표현식 앞에 사용되어 해당 작업이 완료될 때까지 함수의 실행을 일시 중단합니다. async/await는 주로 프로미스 기반의 비동기 작업을 더 간단하고 명확하게 작성하기 위해 사용됩니다.